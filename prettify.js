const data = require('./data.json');
const { dataSince, excludeUsers } = require('./config.json');
const save = require('./utils/save');
const _filtered = data
    .map(item => {
        item.json = JSON.parse(item.json);
        return item;
    })
    .filter(item => excludeUsers.indexOf(item.user.username) === -1)
    .filter(item => !dataSince || item.timestamp >= dataSince)
    .filter(item => item.eventType !== 'RoomUnlockedEvent' || !data.find(i => 
        i.eventType === 'RoomUnlockedEvent' && 
        item.user.username === i.user.username && 
        item.json.roomId === i.json.roomId && 
        item.id > i.id
    ))

if (_filtered.length === 0) {
    throw new Error('No data left after filtering. Maybe you specified a wrong timestamp in config.json?');
}

const didInteract = _filtered
    .reduce((acc, item) => {
        if (!acc[item.user.username]) {
            acc[item.user.username] = false;
        }

        const isInitialEvent = (
            item.eventType === 'GameStartedEvent'
        ) || (
            item.eventType === 'GameProgressionChangedEvent'
            && item.json.progression.id === 1
            && item.json.progression.status === 'TALK'
        );

        if (!isInitialEvent) {
            acc[item.user.username] = true;
        }
        return acc;
    }, []);

const filtered = _filtered.filter(item => didInteract[item.user.username]);
save('data.filtered.json', filtered);


const pretty = filtered
    .map(item => {
        // remove unnecessary user info, flatmap UserComponentKeys
        item.user = item.user.username;
        if (item.json?.userComponentKey) {
            item.json.user = item.json.userComponentKey.user.username;
            item.json.component = item.json.userComponentKey.component.name;
            delete item.json.userComponentKey;
        }

        // remove editable ranges
        if (item.json?.cutSource?.editable) delete item.json.cutSource.editable;
        if (item.json?.testSource?.editable) delete item.json.testSource.editable;
        if (item.json?.autoGeneratedTestSource?.editable) delete item.json.autoGeneratedTestSource.editable;

        // test-executed: wrap test result in object, add component name
        if (item.eventType === 'test-executed') {
            item.json = {
                componentName: item.json.testClassName.replace('Test', ''),
                executionResult: item.json
            };
        }

        // test-/cut-modified: rename component name
        if (item.eventType === 'test-modified' || item.eventType === 'cut-modified') {
            item.json.componentName = item.json.component;
            delete item.json.component;
        }

        // test-execution-failed events do not contain a component name
        if (item.eventType === 'test-execution-failed') {
            const message = item.json;
            const componentName = /.*\n\/(.*?)(Test)?\.java:/.exec(message)[1];
            item.json = {componentName, message};
        }

        // rename json to data
        item.data = item.json;
        delete item.json;

        return item;
    });

save('data.pretty.json', pretty);


const eventTypes = pretty
    .map(item => item.eventType)
    .filter((value, index, self) => self.indexOf(value) === index);

save('eventTypes.json', eventTypes);

const usernames = pretty
    .map(item => item.user)
    .filter((value, index, self) => self.indexOf(value) === index);

save('usernames.json', usernames);
